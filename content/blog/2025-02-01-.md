## Understanding MVC in Rails

### What is MVC?

Model-View-Controller (MVC) is an architectural pattern that separates an application into three main components:

1. **Model**: Handles data and business logic
2. **View**: Manages how the data is displayed
3. **Controller**: Coordinates between Model and View

Here's a visual representation of how MVC works in Rails:

```plaintext
                                    ┌─────────────┐
                                    │   Browser   │
                                    └─────────────┘
                                          ↕
                                    HTTP Request
                                          ↕
┌─────────────┐                 ┌─────────────────┐
│   Routes    │ ───────────────▶│   Controller    │
└─────────────┘                 └─────────────────┘
                                     ↙         ↘
                               Data           Render
                            Request         Response
                                 ↙             ↘
                     ┌─────────────┐    ┌─────────────┐
                     │    Model    │    │    View     │
                     └─────────────┘    └─────────────┘
                            ↕
                     ┌─────────────┐
                     │  Database   │
                     └─────────────┘
```

### Why Rails Chose MVC?

Rails adopted MVC for several crucial reasons:

1. **Separation of Concerns**

   - Each component has a specific responsibility
   - Makes code more maintainable and testable
   - Enables parallel development by different teams

2. **Convention over Configuration**

   - Standardized file structure
   - Predictable code organization
   - Reduced setup time for new projects

3. **DRY (Don't Repeat Yourself)**
   - Reusable components
   - Shared logic through concerns
   - Maintainable codebase

Let's look at a real-world example of how MVC works in Rails:

### Real-World Example: E-commerce Product Management

#### 1. Model Layer (Business Logic)

```ruby
# app/models/product.rb
class Product < ApplicationRecord
  belongs_to :category
  has_many :order_items
  has_many :orders, through: :order_items
  has_many_attached :images

  # Validations
  validates :name, presence: true, length: { minimum: 3 }
  validates :price, presence: true, numericality: { greater_than: 0 }
  validates :sku, presence: true, uniqueness: true

  # Scopes for common queries
  scope :in_stock, -> { where('stock_count > ?', 0) }
  scope :featured, -> { where(featured: true) }
  scope :price_range, ->(min, max) { where(price: min..max) }

  # Business logic methods
  def available_for_purchase?(quantity = 1)
    stock_count >= quantity
  end

  def low_stock?
    stock_count < reorder_threshold
  end

  def discount_price(percentage)
    price * (1 - percentage / 100.0)
  end

  # Inventory management
  def reduce_stock(quantity)
    with_lock do
      if available_for_purchase?(quantity)
        update!(stock_count: stock_count - quantity)
        notify_low_stock if low_stock?
        true
      else
        false
      end
    end
  end

  private

  def notify_low_stock
    ProductMailer.low_stock_alert(self).deliver_later
    SlackNotifier.new.notify("#inventory", "Low stock alert for #{name} (SKU: #{sku})")
  end
end
```

#### 2. Controller Layer (Request Handling)

```ruby
# app/controllers/products_controller.rb
class ProductsController < ApplicationController
  before_action :set_product, only: [:show, :edit, :update, :destroy]
  before_action :require_admin, except: [:index, :show]

  def index
    @products = Product.includes(:category)
                      .with_attached_images
                      .page(params[:page])

    # Filter products based on user preferences
    @products = @products.in_stock if params[:in_stock]
    @products = @products.featured if params[:featured]
    @products = @products.price_range(params[:min_price], params[:max_price]) if params[:min_price].present?

    respond_to do |format|
      format.html
      format.json { render json: @products }
      format.csv { send_data @products.to_csv }
    end
  end

  def show
    # Track product views for analytics
    track_product_view(@product)

    # Load related products
    @related_products = @product.category.products
                               .where.not(id: @product.id)
                               .limit(4)

    # Check user-specific pricing
    @user_price = current_user&.special_price_for(@product)
  end

  def create
    @product = Product.new(product_params)

    if @product.save
      # Handle image uploads
      params[:product][:images]&.each do |image|
        @product.images.attach(image)
      end

      # Update search index
      @product.reindex_async

      # Notify subscribers
      NotifySubscribersJob.perform_later(@product)

      redirect_to @product, notice: 'Product was successfully created.'
    else
      render :new
    end
  end

  private

  def product_params
    params.require(:product).permit(
      :name, :description, :price, :sku,
      :category_id, :stock_count, :featured,
      :reorder_threshold, images: []
    )
  end

  def track_product_view(product)
    Analytics.track(
      user_id: current_user&.id,
      event: 'Product Viewed',
      properties: {
        product_id: product.id,
        category: product.category.name,
        price: product.price
      }
    )
  end
end
```

#### 3. View Layer (User Interface)

```erb
<!-- app/views/products/show.html.erb -->
<div class="product-detail">
  <% content_for :title do %>
    <%= @product.name %> - <%= @product.category.name %>
  <% end %>

  <div class="product-images">
    <%= render 'shared/image_gallery', images: @product.images %>
  </div>

  <div class="product-info">
    <h1><%= @product.name %></h1>

    <div class="pricing">
      <% if @user_price %>
        <div class="special-price">
          <del><%= number_to_currency(@product.price) %></del>
          <span class="your-price">
            <%= number_to_currency(@user_price) %>
          </span>
        </div>
      <% else %>
        <div class="regular-price">
          <%= number_to_currency(@product.price) %>
        </div>
      <% end %>
    </div>

    <div class="stock-status">
      <% if @product.available_for_purchase? %>
        <%= render 'add_to_cart_form', product: @product %>
      <% else %>
        <%= render 'out_of_stock_notification', product: @product %>
      <% end %>
    </div>

    <div class="product-description">
      <%= sanitize @product.description %>
    </div>

    <% if @product.low_stock? %>
      <div class="stock-warning">
        Only <%= @product.stock_count %> items left!
      </div>
    <% end %>
  </div>

  <%= render 'related_products', products: @related_products %>
</div>

<!-- app/views/shared/_image_gallery.html.erb -->
<div class="image-gallery" data-controller="gallery">
  <div class="main-image">
    <%= image_tag images.first.variant(resize: "800x800") if images.any? %>
  </div>

  <div class="thumbnails">
    <% images.each do |image| %>
      <div class="thumbnail" data-action="click->gallery#select">
        <%= image_tag image.variant(resize: "100x100") %>
      </div>
    <% end %>
  </div>
</div>
```

### How MVC Components Work Together

Let's see how these components interact in a typical product page request:

1. **Route Processing**

```ruby
# config/routes.rb
Rails.application.routes.draw do
  resources :products do
    member do
      post 'add_to_cart'
      get 'price_history'
    end

    collection do
      get 'search'
      get 'categories/:category_id', to: 'products#index', as: :category
    end
  end
end
```

2. **Request Flow**

```plaintext
1. User visits /products/123
2. Routes direct to ProductsController#show
3. Controller loads product data from Model
4. Model applies business logic and fetches from database
5. Controller passes data to View
6. View renders HTML with product information
7. Response sent back to user
```
